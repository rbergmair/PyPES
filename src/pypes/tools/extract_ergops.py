# -*-  coding: ascii -*-  # # # # # # # # # # # # # # # # # # # # # # # # # # #

__package__ = "pypes.tools";
__all__ = [ "extract_ergops", "main" ];

import sys;
import pprint;

from pyparsing import Literal, LineStart;
from pyparsing import Word as Word_;
from pyparsing import ZeroOrMore, OneOrMore;
from pyparsing import printables;

from pypes.native.ergmrs import ERGMRSInterpreter;



# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

_nonspecial = "";
for ch in printables:
  if not ch in ".:<=&,#[]$()>!^}/+;":
    if not ch.isspace():
      _nonspecial += ch;


typename = Word_( _nonspecial, _nonspecial );

typedef = LineStart() + \
          typename + \
          ( Literal( ":=" ) | Literal( ":<" ) ) + \
          typename + \
          ZeroOrMore( Literal( "&" ) + typename ) + \
          ( ( Literal( "&" ) + Literal( "[" ) ) | Literal( "." ) );

def _decode_typedef( str_, loc, toks ):
  
  subtype = None;
  suptypes = set();
  
  i = 0;
  subtype = toks[i];
  
  i += 1;
  
  assert toks[i] in { ":=", ":<" };
  
  i += 1;
  
  while True:

    if toks[i] == "[":
      break;
    
    suptypes.add( toks[i] );
    i += 1;

    if toks[i] == ".":
      break;
    
    assert toks[i] == "&";
    i += 1;
  
  return ( subtype, suptypes );

typedef.setParseAction( _decode_typedef );


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

def check_nonpredtypes( invtypes, nonpred_types ):
  
  for type_ in nonpred_types:
  
    x = [ type_ ];
    i = 0;
    
    while True:
      
      if i >= len(x):
        break;
      
      subtype = x[i];
      i += 1;
      
      if subtype in invtypes:
        for suptype in invtypes[ subtype ]:
          x.append( suptype );
      
      if subtype[ -4: ] == "_rel":
        print( "WARNING: relation type \"" + subtype + "\" appears" + \
               " to be a supertype of the non-relation type \"" + \
               type_ + "\"" );


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

def check_wordtypes( types, wordtypes ):

  for type_ in wordtypes:

    x = [ type_ ];
    i = 0;
    
    while True:
      
      if i >= len(x):
        break;
      
      suptype = x[i];
      i += 1;
      
      if suptype in types:
        for subtype in types[ suptype ]:
          x.append( subtype );
      
      if suptype[0] != "_":
        print( "WARNING: non-word type \"" + suptype + "\" appears" + \
               " to be a subtype of the word type \"" + \
               type_ + "\"" );


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


def extract_erg_pred_types( f ):
  
  types = {};
  invtypes = {};
  
  r = typedef.scanString( f.read() );
  for (result, cfrom, cto) in r:
    ( subtype, suptypes ) = result[0];
    invtypes[ subtype ] = suptypes;
    for suptype in suptypes:
      if not suptype in types:
        types[ suptype ] = set();
      types[ suptype ].add( subtype );
  
  nonpred_types = set();
  word_types = set();
  pred_types = {};
  
  x = [ "predsort" ];
  i = 0;
  
  while True:
    
    if i >= len(x):
      break;
    
    suptype = x[i];
    i += 1;
    
    if suptype in types:
      for subtype in types[ suptype ]:
        x.append( subtype );

    if suptype[ -4: ] != "_rel":
      
      if suptype != "predsort":
        nonpred_types.add( suptype );
    
    else:
      
      if suptype[0] == "_":
        
        word_types.add( suptype );
      
      else:
      
        if not suptype in types:
          
          pred_types[ suptype[ :-4 ].upper() ] = None;
          
        else:
          
          subtypes = types[ suptype ];
          
          subtypes_ = set();
          for subtype in subtypes:
            if subtype[0] != "_":
              subtypes_.add( subtype[ :-4 ].upper() );
          if len( subtypes_ ) > 0:
            pred_types[ suptype[ :-4].upper() ] = subtypes_;
          else:
            pred_types[ suptype[ :-4].upper() ] = None;
  
  check_nonpredtypes( invtypes, nonpred_types );
  check_wordtypes( types, word_types );
  
  print( len( pred_types ) );
  
  return pred_types;



# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

def write_ops( types, g ):
  
  g.write( """# -*-  coding: ascii\n""" )
  g.write( """# autogenerated by extract_ergops.py\n""" )
  g.write( """__package__ = "native";\n""" );
  g.write( """__all__ = [ "Operator" ];\n""" );
  g.write( """import pypes.proto;\n""" );
  g.write( """class Operator( pypes.proto.Operator ):\n""" );
  
  for type_ in sorted( types ):
    type__ = ERGMRSInterpreter._predstr_to_operator( type_ );
    g.write( "  " + type__ + " = " + repr( type__ ) +";\n" );

  g.write( "\n  OPs = {\n" );

  for type_ in sorted( types ):
    type__ = ERGMRSInterpreter._predstr_to_operator( type_ );
    g.write( "    " + type__ + ": " + type__ + ",\n" );

  g.write( "  };\n" );
  
  types_ = pprint.pformat( types, width=72 );
  types_ = types_.replace( "'", "" ).replace( "-", "_" ).replace( "\n", "\n   " );

  g.write( "\n  TYPEGRAPH = " );
  g.write( types_ );

  g.write( ";\n" );



# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

def main( argv=None ):
  
  f = open( "/local/scratch/rb432/delphin/erg/fundamentals.tdl" );
  g = open( "/local/scratch/rb432/tmp/ops/ergops_auto.py", "w" );
  write_ops( extract_erg_pred_types( f ), g );
  g.close();
  f.close();
  return 0;



# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

if __name__ == '__main__':
  sys.exit( main( sys.argv ) );



# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
#                                                                             #
#        PyPES: the python platform for experimentation with semantics        #
#                                                                             #
#                  (c) Copyright 2009 by Richard Bergmair                     #
#       -----------------------------------------------------------------     #
#       See LICENSE.txt for terms and conditions on use and reproduction.     #
#                                                                             #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
